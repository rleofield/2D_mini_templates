/* --------------------------------------------------------------------------
    Copyright 2012 by Richard Albrecht
    richard.albrecht@rleofield.de

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ------------------------------------------------------------------------------
*/

#include <iostream>
#include <string>
#include <typeinfo>
#include <string>
#include <boost/lexical_cast.hpp>
#include <float.h>
#include <vector>
#include <cmath>
#include <assert.h>
#include "t_2D_xy.h"

using namespace std;





using namespace matrix;

	void test_matrix(){
      float_v2 v0(1.0f,2.0f);
      float_v2 v1(3.0f,4.0f);
      float_m2 mf2( v0, v1 );

      float a = mf2[0][0];
      float b = mf2[0][1];
      float c = mf2[1][0];
      float d = mf2[1][1];
      float_m2 mf_x ;

      float_m2 mf_s  = getScaleMatrix<float>( float_v2(3.0f, 2.0f) );
      float_m2 mf_s2 = getScaleMatrix<float>( float_v2(3.0f, 6.0f) );

      mf_s = float_m2(   float_v2( 1.0f, 3.0f ), float_v2(5.0f, 6.0f ) ); //
      mf_s2 = float_m2(  float_v2( 2.0f, 1.0f ), float_v2(7.0f, 5.0f ) ); //

      float_m2 mf_s3 = mf_s * mf_s2;

      float e = 0.0f;

   }

using namespace pnt;

	void test_xy(){
		cout << "test xy " << endl;
		float_xy xy0(0.0f,0.0f);
		float_xy xy1(0.0f,0.0f);
		if( xy0 == xy1 ){
			cout << "test ok " << endl;

		}
		else{
			cout << "test nok " << endl;

	}

		float e = 0.0f;

}


   void test_float(){
      // test float/double compare
      cout << "float == "<< endl;
         float_xy fxy0(1000.0f,1000.0f);
         float_xy fxy1(1000.1f,1000.0f); // equal with epsilon = 1.1920929e-006
         cout << "fxy0(1000.0,1000.0) == fxy1(1000.001,1000.0)" << endl;
         if( fxy0 == fxy1 ){
            cout << "true" << endl;
         }else{
            cout << "false" << endl;
         }

         float_xy f2xy0(0.0001f,0.0001f);
         float_xy f2xy1(0.0001000001f,0.0001f);  // equal with epsilon = 1.1920929e-006
         cout << "f2xy0(0.0001,0.0001) == f2xy1(0.0001000001,0.0001)" << endl;
         if( f2xy0 == f2xy1 ){
            cout << "true" << endl;
         }else{
            cout << "false" << endl;
         }


         cout << "double == "<< endl;

         // equal with epsilon = 	2.2204460492503131e-015
         double_xy dxy0(1000.0,1000.0);
         double_xy dxy1(1000.00000000000001,1000.0);
         cout << "dxy0(1000.0,1000.0) == dxy1(1000.00000000000001,1000.0)" << endl;
         if( dxy0 == dxy1 ){
            cout << "true" << endl;
         }else{
            cout << "false" << endl;
         }


         // == with epsilon = 2.2204460492503131e-015
         double_xy d2xy0( 0.0001, 0.0001 );
         double_xy d2xy1( 0.000100000000000001, 0.0001 );
         cout << "d2xy0( 0.0001, 0.0001 ) == d2xy1( 0.00010000000000000001, 0.0001 )" << endl;
         if( d2xy0 == d2xy1 ){
            cout << "true" << endl;
         }else{
            cout << "false" << endl;
         }



   }

int main() {

   //test_matrix();
   test_float();

   return 0;
}

